---
title: "Assistant de voyage personnel"
author: "Ines VAZ, Kanto RALANTOMALALA, Lucas RAKOTOMALALA"
date: "2026-01-07"
output:
  html_document: default
  pdf_document: default
---

# INSTALLER LES PACKAGES

Avant de lancer l'application, on installe les packages n√©cessaires : 
- shiny sert √† cr√©er l'interface interactive
- readr permet de lire les fichiers de donn√©es
- shinythemes sert √† ajouter un th√®me graphique

```{r}  
install.packages("shiny")
install.packages("readr")
install.packages("shinythemes")
library(shiny)
library(readr)
library(shinythemes)
```

# CODE

```{r}
# ============================================================
# 1. CHARGEMENT DES DONN√âES
# ============================================================

# on importe le dataset contenant toutes les destinations et leurs caract√©ristiques

  donnees <- read.csv("~/Library/CloudStorage/OneDrive-etu.unistra.fr/travel_recommendations.csv", stringsAsFactors = FALSE)

# ============================================================
# 2. DICTIONNAIRES DE TRADUCTION
# ============================================================

# Le dataset est en anglais, mais on voulais que l'interface est en francais, donc on a cr√©e des dictionnaires qui associent le texte affich√© √† l'utilisateur (fran√ßais) √† la valeur r√©elle pr√©sente dans le dataset (anglais)

  trad_cat <- c("Aventure" = "adventure", "Plages" = "beaches", "Culture" = "culture", 
                "D√©sert" = "desert", "For√™t" = "forest", "√éles" = "islands", "Montagnes" = "mountains")
  trad_comp <- c("En couple" = "couple", "En famille" = "family", "Entre amis" = "friends", "Seul(e)" = "solo")
  trad_clim <- c("Froid/Doux" = "cold/mild", "Chaud/Sec" = "hot/dry", "Humide" = "humid", 
                 "Doux" = "mild", "Tropical" = "tropical", "Tropical/Chaud" = "tropical/warm", "Variable" = "variable")
  trad_frequent <- c("Anim√©" = "lively", "Mod√©r√©" = "Moderate", "Calme" = "quiet")
  trad_mois <- c("Janvier" = "January", "F√©vrier" = "February", "Mars" = "March", "Avril" = "April", 
                 "Mai" = "May", "Juin" = "June", "Juillet" = "July", "Ao√ªt" = "August", 
                 "Septembre" = "September", "Octobre" = "October", "Novembre" = "November", "D√©cembre" = "December")
  trad_act <- c("Balades en bateau" = "boat rides", "Promenades √† chameau" = "camel rides", 
                "Parcours historiques" = "heritage walks", "Randonn√©e" = "hiking", 
                "Visites de mus√©es" = "museum tours", "Marches en pleine nature" = "nature walks", 
                "Parapente" = "paragliding", "Rafting" = "rafting", "Sandboarding" = "sandboarding", 
                "Snorkeling" = "snorkeling", "Baignade" = "swimming", "Trekking" = "trekking", 
                "Safari photo" = "wildlife safari")

# ============================================================
# 3. INTERFACE UTILISATEUR (UI)
# ============================================================

# La partie UI d√©finit tout ce que l‚Äôutilisateur voit √† l‚Äô√©cran :
# titres, menus d√©roulants, boutons et zones d‚Äôaffichage des r√©sultats.


ui <- fluidPage(
    theme = shinytheme("sandstone"),
  
  # Effet Confettis
  tags$head(
    tags$script(src = "https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"),
    tags$script(HTML("window.onload = function() { confetti({particleCount: 100, spread: 70, origin: { y: 0.6 }}); };"))
  ),

  
  titlePanel("üåç Assistant Voyage Personnel"),
  
  sidebarLayout(
    
    #ici : c'est le panneau gauche, c'est √† dire la saisie des pr√©f√©rences utilisateur
    
    sidebarPanel(
      h4("‚úàÔ∏è Vos pr√©f√©rences"),
      selectInput("cat", "Type de voyage :", choices = names(trad_cat)),
      selectInput("comp", "Accompagnants :", choices = names(trad_comp)),
      selectInput("mois", "Mois de d√©part :", choices = names(trad_mois)),
      selectInput("clim", "Climat pr√©f√©r√© :", choices = names(trad_clim)),
      selectInput("freq", "Fr√©quentation :", choices = names(trad_frequent)),
      selectInput("act", "Activit√© favorite :", choices = names(trad_act)),
      hr(),
      actionButton("go", "Trouver ma destination ‚úàÔ∏è", class = "btn-success", width = "100%")
    ),
    
    # ici : c'est le panneau droit : affichage des r√©sultats
    
    mainPanel(
      h3("üèùÔ∏è Nos suggestions pour vous :"),
      # Zone de message d'erreur personnalis√©e si rien n'est trouv√©
      uiOutput("message_vide"),
      tableOutput("resultats"),
      
      # Filtres prioritaires
      uiOutput("prio_ui")
    )
  )
)

# ============================================================
# 4. LOGIQUE SERVEUR (SERVER)
# ============================================================

# La partie server contient toute la logique : traitement des choix utilisateur, calcul des scores, et g√©n√©ration des r√©sultats affich√©s.
  

server <- function(input, output, session) {
  valeurs <- reactiveValues(top_voyages = NULL, scores = NULL)
  
  # Cette partie s‚Äôex√©cute lorsque l‚Äôutilisateur clique sur le bouton
  observeEvent(input$go, {
    req_cat  <- trad_cat[input$cat]
    req_comp <- trad_comp[input$comp]
    req_mois <- trad_mois[input$mois]
    req_clim <- trad_clim[input$clim]
    req_freq <- trad_frequent[input$freq]
    req_act  <- trad_act[input$act]

    # On ajoute 1 point √† chaque fois qu‚Äôun crit√®re correspond
    scores <- rep(0, nrow(donnees))
    scores <- scores + (tolower(donnees$category) == req_cat)
    scores <- scores + (tolower(donnees$companions) == req_comp)
    scores <- scores + (tolower(donnees$climate) == req_clim)
    scores <- scores + (tolower(donnees$crowd_level) == req_freq)
    scores <- scores + grepl(req_mois, donnees$best_months, ignore.case = TRUE)
    scores <- scores + grepl(req_act, donnees$activities, ignore.case = TRUE)
    
    # S√©lection des 3 meilleures destinations selon le score total
    top_indices <- order(scores, decreasing = TRUE)[1:3]
    res <- donnees[top_indices, ]
    
    # Calcul d‚Äôun pourcentage d‚Äôad√©quation pour un affichage plus clair
    res$Adequation <- paste0(round((scores[top_indices] / 6) * 100), "%")
    
    valeurs$top_voyages <- res
    valeurs$scores <- scores
    
    showNotification("Bon voyage ‚úàÔ∏è!", type = "message")
  })

  
  # Affichage du tableau des r√©sultats
  output$resultats <- renderTable({
    req(valeurs$top_voyages)
    # On affiche tout le tableau s√©lectionn√© sans nommer les colonnes √† la main
    # Cela √©vite l'erreur "undefined columns"
    valeurs$top_voyages
  }, striped = TRUE, hover = TRUE, bordered = TRUE)

  # Interface suppl√©mentaire pour imposer deux crit√®res prioritaires
  output$prio_ui <- renderUI({
    req(valeurs$top_voyages)
    tagList(
      hr(),
      h4("‚öôÔ∏è Pas satisfait ? Imposez 2 crit√®res prioritaires"),
      fluidRow(
        column(6, selectInput("crit1", "Priorit√© 1", choices = list("Type de voyage"=1, "accompagnant"=2, "Mois"=3, "Climat"=4, "Fr√©quentation"=5, "Activit√©"=6))),
        column(6, selectInput("crit2", "Priorit√© 2", choices = list("Type de voyage"=1, "accompagnant"=2, "Mois"=3, "Climat"=4, "Fr√©quentation"=5, "Activit√©"=6)))
      ),
      actionButton("prio_btn", "Appliquer le filtre strict", class = "btn-warning"),
      br(), br(),
      span(textOutput("prio_res"), style="font-weight:bold; font-size: 1.2em; color: #2c3e50;")
    )
  })

# Application du filtre strict bas√© sur les deux priorit√©s choisies
  
  observeEvent(input$prio_btn, {
    req(valeurs$scores)
    
    
    # Fonction qui v√©rifie si une destination respecte un crit√®re donn√©
    verifier <- function(idx, num) {
      if (num == 1) return(tolower(donnees$category[idx]) == trad_cat[input$cat])
      if (num == 2) return(tolower(donnees$companions[idx]) == trad_comp[input$comp])
      if (num == 3) return(grepl(trad_mois[input$mois], donnees$best_months[idx], ignore.case = TRUE))
      if (num == 4) return(tolower(donnees$climate[idx]) == trad_clim[input$clim])
      if (num == 5) return(tolower(donnees$crowd_level[idx]) == trad_frequent[input$freq])
      if (num == 6) return(grepl(trad_act[input$act], donnees$activities[idx], ignore.case = TRUE))
      return(TRUE)
    }

    
    # On teste toutes les destinations et on garde seulement celles qui respectent les deux priorit√©s en m√™me temps
    strict <- sapply(1:nrow(donnees), function(i) verifier(i, as.numeric(input$crit1)) && verifier(i, as.numeric(input$crit2)))

    # Affichage du meilleur r√©sultat strict
    output$prio_res <- renderText({
      if (any(strict)) {
        possibilites <- donnees[strict, ]
        best <- possibilites$destination[order(valeurs$scores[strict], decreasing = TRUE)[1]]
        paste("üåü La meilleure destination respectant strictement vos priorit√©s est :", best)
      } else {
        "üòï Aucune destination trouv√©e, essayez d'autres crit√®res"
      }
    })
  })
}

# lancement de l'application shiny  
shinyApp(ui, server)
```